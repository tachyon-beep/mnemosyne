/**
 * Follow-up Detection System - Advanced commitment language detection and follow-up tracking
 * 
 * This service provides comprehensive tracking of commitments, promises, and action items
 * with intelligent follow-up suggestions and stale action detection.
 * 
 * Features:
 * - Multi-pattern commitment detection (action, temporal, conditional, delegated)
 * - Entity-aware follow-up tracking with relationship context
 * - Configurable staleness detection with urgency awareness
 * - Smart follow-up suggestions based on conversation patterns
 * - Completion indicator detection and resolution tracking
 */

import { BaseRepository } from '../../../storage/repositories/BaseRepository.js';
import { Message } from '../../../types/interfaces.js';
import { Entity, EntityType } from '../../../storage/repositories/EntityRepository.js';
import { EntityRelationship } from '../../../entities/RelationshipDetector.js';

/**
 * Represents a detected commitment in conversation
 */
export interface DetectedCommitment {
  /** Unique identifier for this commitment */
  id: string;
  /** The message containing the commitment */
  message: Message;
  /** Type of commitment detected */
  commitmentType: CommitmentType;
  /** Extracted commitment text */
  commitmentText: string;
  /** Pattern that matched the commitment */
  matchedPattern: string;
  /** Confidence score (0-1) */
  confidence: number;
  /** Entities mentioned in the commitment */
  entities: Entity[];
  /** Expected resolution timeframe in days */
  expectedTimeframeDays?: number;
  /** Urgency level based on language and context */
  urgencyLevel: UrgencyLevel;
  /** Days since commitment was made */
  daysSinceCommitment: number;
  /** Status of the commitment */
  status: CommitmentStatus;
  /** Related follow-up messages */
  followUps: Message[];
  /** Conversation context */
  conversationContext: {
    conversationId: string;
    conversationTitle?: string;
    participantCount: number;
  };
}

/**
 * Types of commitments that can be detected
 */
export type CommitmentType = 
  | 'action'        // "I'll check", "let me"
  | 'temporal'      // "by Friday", "next week"
  | 'conditional'   // "if X then I'll Y"
  | 'delegated'     // "can you", "please"
  | 'investigation' // "look into", "investigate"
  | 'update'        // "I'll update", "keep you posted"
  | 'follow_up'     // "get back to you", "circle back"

/**
 * Urgency levels for commitments
 */
export type UrgencyLevel = 'low' | 'normal' | 'high' | 'urgent';

/**
 * Status of commitment tracking
 */
export type CommitmentStatus = 'pending' | 'acknowledged' | 'in_progress' | 'completed' | 'overdue' | 'cancelled';

/**
 * Temporal commitment with specific time reference
 */
export interface TemporalCommitment extends DetectedCommitment {
  commitmentType: 'temporal';
  /** Specific deadline extracted from text */
  deadline?: number;
  /** Time reference type */
  timeReference: 'absolute' | 'relative' | 'recurring';
  /** Original time expression */
  timeExpression: string;
}

/**
 * Stale action that needs follow-up
 */
export interface StaleAction {
  /** The original commitment */
  commitment: DetectedCommitment;
  /** Days since it became stale */
  daysSinceStale: number;
  /** Staleness level */
  stalenessLevel: 'mildly_stale' | 'stale' | 'very_stale' | 'abandoned';
  /** Reason why it's considered stale */
  stalenessReason: string;
  /** Suggested follow-up actions */
  suggestedActions: FollowupSuggestion[];
  /** Related entities for context */
  relatedEntities: Entity[];
}

/**
 * Follow-up suggestion generated by the system
 */
export interface FollowupSuggestion {
  /** Unique identifier for the suggestion */
  id: string;
  /** Type of follow-up suggested */
  suggestionType: FollowupType;
  /** Priority level */
  priority: 'low' | 'medium' | 'high' | 'urgent';
  /** Suggested action text */
  suggestionText: string;
  /** Confidence in the suggestion (0-1) */
  confidence: number;
  /** Context for the suggestion */
  context: string;
  /** Related entities */
  relatedEntities: Entity[];
  /** Estimated urgency based on patterns */
  estimatedUrgency: UrgencyLevel;
  /** Whether this suggestion is time-sensitive */
  isTimeSensitive: boolean;
}

/**
 * Types of follow-up suggestions
 */
export type FollowupType = 
  | 'status_check'     // Check on progress
  | 'deadline_reminder' // Remind about deadline
  | 'context_update'   // Request context update
  | 'escalation'       // Escalate to relevant party
  | 'clarification'    // Ask for clarification
  | 'completion_verify' // Verify if completed
  | 'timeline_adjust'  // Suggest timeline adjustment

/**
 * Configuration for staleness detection
 */
export interface StalenessConfig {
  /** Default staleness threshold in days */
  defaultStaleDays: number;
  /** Urgency-based thresholds */
  urgencyThresholds: {
    low: number;      // Days before low urgency items are stale
    normal: number;   // Days before normal items are stale
    high: number;     // Days before high urgency items are stale
    urgent: number;   // Days before urgent items are stale
  };
  /** Entity-specific staleness rules */
  entityBasedRules: {
    [entityType in EntityType]?: number;
  };
  /** Commitment type specific rules */
  commitmentTypeRules: {
    [type in CommitmentType]?: number;
  };
}

/**
 * Follow-up Detection Service
 */
export class FollowupDetector extends BaseRepository {

  /**
   * Comprehensive commitment detection patterns
   */
  private static readonly COMMITMENT_PATTERNS = {
    // Action commitments - immediate or near-term actions
    action: [
      /I'll\s+(?:check|verify|look|see|try|do|make|send|call|contact|review|examine)/i,
      /(?:let me|I need to|I should)\s+(?:check|verify|look|see|try|do|make|send|call|contact|review|examine)/i,
      /I'm going to\s+(?:check|verify|look|see|try|do|make|send|call|contact|review|examine)/i,
      /(?:I plan to|I intend to)\s+(?:check|verify|look|see|try|do|make|send|call|contact|review|examine)/i,
    ],
    
    // Temporal commitments - time-bound promises
    temporal: [
      /(?:by|before|after|on)\s+(?:tomorrow|today|tonight|this\s+(?:morning|afternoon|evening|week|month))/i,
      /(?:by|before|after|on)\s+(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
      /(?:by|before|after|on)\s+(?:next\s+(?:week|month|friday|monday|tuesday|wednesday|thursday))/i,
      /(?:by|before|after|on)\s+(?:end\s+of\s+(?:day|week|month|quarter|year))/i,
      /(?:in|within)\s+(?:an?\s+)?(?:hour|day|week|month|few\s+(?:hours|days|weeks))/i,
      /(?:by|before)\s+\d{1,2}(?::\d{2})?\s*(?:am|pm)?/i,
    ],
    
    // Conditional commitments - if-then promises
    conditional: [
      /if\s+.*?\s+(?:then\s+)?(?:I'll|I will|let me|I can|I should)/i,
      /(?:assuming|provided|given)\s+.*?(?:I'll|I will|let me|I can)/i,
      /(?:once|when|after)\s+.*?(?:I'll|I will|let me|I can)/i,
    ],
    
    // Delegated commitments - requests to others
    delegated: [
      /(?:can|could|would)\s+you\s+(?:please\s+)?(?:check|verify|look|see|try|do|make|send|call|contact)/i,
      /please\s+(?:check|verify|look|see|try|do|make|send|call|contact|review|examine)/i,
      /(?:would\s+you\s+mind|could\s+you\s+please)\s+(?:checking|verifying|looking|seeing|trying)/i,
      /I'd appreciate if you could\s+(?:check|verify|look|see|try|do|make|send|call|contact)/i,
    ],
    
    // Investigation commitments - research and analysis
    investigation: [
      /(?:I'll|let me|I need to)\s+(?:investigate|research|explore|analyze|study|examine)/i,
      /(?:I'll|let me|I need to)\s+(?:look into|dig into|check out|find out)/i,
      /(?:I'll|let me|I need to)\s+(?:get to the bottom of|figure out|determine)/i,
    ],
    
    // Update commitments - status and progress reports
    update: [
      /(?:I'll|I will)\s+(?:update|inform|notify|let\s+you\s+know|keep\s+you\s+posted)/i,
      /(?:I'll|I will)\s+(?:send\s+an?\s+update|provide\s+an?\s+update|give\s+you\s+an?\s+update)/i,
      /(?:I'll|I will)\s+(?:report\s+back|circle\s+back|touch\s+base)/i,
    ],
    
    // Follow-up commitments - future engagement
    follow_up: [
      /(?:I'll|I will)\s+(?:follow\s+up|get\s+back\s+to\s+you|circle\s+back)/i,
      /(?:I'll|I will)\s+(?:reach\s+out|be\s+in\s+touch|contact\s+you)/i,
      /(?:let's|we\s+should)\s+(?:follow\s+up|touch\s+base|reconnect)/i,
    ]
  };

  /**
   * Patterns for detecting completion indicators
   */
  private static readonly COMPLETION_PATTERNS = [
    /(?:completed|finished|done|resolved|fixed|solved|implemented)/i,
    /(?:I've|I have)\s+(?:checked|verified|looked|reviewed|examined|contacted|sent)/i,
    /(?:it's|this\s+is)\s+(?:complete|finished|done|resolved|ready)/i,
    /(?:problem\s+(?:solved|resolved|fixed)|issue\s+(?:resolved|fixed|closed))/i,
    /(?:task\s+(?:complete|finished|done)|work\s+(?:complete|finished|done))/i,
  ];

  /**
   * Patterns for detecting acknowledgment
   */
  private static readonly ACKNOWLEDGMENT_PATTERNS = [
    /(?:got\s+it|understood|acknowledged|noted|thanks|okay|ok|sure)/i,
    /(?:I'll\s+(?:work\s+on|start|begin)|working\s+on|started)/i,
    /(?:in\s+progress|ongoing|currently\s+(?:working|checking|looking))/i,
  ];

  /**
   * Default staleness configuration
   */
  private static readonly DEFAULT_STALENESS_CONFIG: StalenessConfig = {
    defaultStaleDays: 7,
    urgencyThresholds: {
      low: 14,
      normal: 7,
      high: 3,
      urgent: 1
    },
    entityBasedRules: {
      person: 5,
      organization: 10,
      product: 7,
      technical: 3,
      event: 1,
      decision: 2
    },
    commitmentTypeRules: {
      action: 3,
      temporal: 0, // Based on deadline
      conditional: 7,
      delegated: 5,
      investigation: 10,
      update: 7,
      follow_up: 7
    }
  };

  /**
   * Detect commitment language in messages
   */
  async detectCommitmentLanguage(
    messages: Message[],
    options: {
      minConfidence?: number;
      includeEntities?: boolean;
      conversationContext?: boolean;
    } = {}
  ): Promise<DetectedCommitment[]> {
    const {
      minConfidence = 0.6,
      includeEntities = true,
      conversationContext = true
    } = options;

    const commitments: DetectedCommitment[] = [];

    for (const message of messages) {
      const detectedCommitments = await this.analyzeMessageForCommitments(
        message,
        { minConfidence, includeEntities, conversationContext }
      );
      commitments.push(...detectedCommitments);
    }

    return commitments
      .filter(commitment => commitment.confidence >= minConfidence)
      .sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Track temporal promises with specific time references
   */
  async trackTemporalPromises(
    conversationId?: string,
    options: {
      includePast?: boolean;
      includeCompleted?: boolean;
      maxDaysAhead?: number;
    } = {}
  ): Promise<TemporalCommitment[]> {
    const {
      includePast = false,
      includeCompleted = false,
      maxDaysAhead = 30
    } = options;

    // Find messages with temporal commitment patterns
    let whereClause = 'WHERE m.role = ?';
    const params: any[] = ['assistant'];

    if (conversationId) {
      whereClause += ' AND m.conversation_id = ?';
      params.push(conversationId);
    }

    if (!includePast) {
      whereClause += ' AND m.created_at >= ?';
      params.push(Date.now() - (7 * 24 * 60 * 60 * 1000)); // Last 7 days
    }

    const messages = this.executeStatementAll<{
      id: string;
      conversation_id: string;
      role: string;
      content: string;
      created_at: number;
      parent_message_id: string | null;
      metadata: string;
    }>(
      'find_temporal_messages',
      `SELECT m.* FROM messages m ${whereClause} ORDER BY m.created_at DESC`,
      params
    );

    const temporalCommitments: TemporalCommitment[] = [];

    for (const row of messages) {
      const message: Message = this.mapRowToMessage(row);
      const commitments = await this.analyzeMessageForCommitments(message, { 
        minConfidence: 0.5, 
        includeEntities: false, 
        conversationContext: false 
      });
      
      for (const commitment of commitments) {
        if (commitment.commitmentType === 'temporal') {
          const temporal = commitment as TemporalCommitment;
          
          if (!includeCompleted && temporal.status === 'completed') {
            continue;
          }

          // Parse time references
          const timeInfo = this.extractTemporalInfo(temporal.commitmentText);
          if (timeInfo) {
            temporal.deadline = timeInfo.deadline;
            temporal.timeReference = timeInfo.timeReference;
            temporal.timeExpression = timeInfo.timeExpression;

            // Filter by time window
            if (temporal.deadline && temporal.deadline > Date.now() + (maxDaysAhead * 24 * 60 * 60 * 1000)) {
              continue;
            }

            temporalCommitments.push(temporal);
          }
        }
      }
    }

    return temporalCommitments.sort((a, b) => (a.deadline || 0) - (b.deadline || 0));
  }

  /**
   * Identify stale actions that need follow-up
   */
  async identifyStaleActions(
    options: {
      conversationId?: string;
      stalenessConfig?: Partial<StalenessConfig>;
      includeEntityContext?: boolean;
    } = {}
  ): Promise<StaleAction[]> {
    const config = { ...FollowupDetector.DEFAULT_STALENESS_CONFIG, ...options.stalenessConfig };
    const staleActions: StaleAction[] = [];

    // Get all pending and in-progress commitments
    const allCommitments = await this.getAllCommitments(options.conversationId);
    const activeCommitments = allCommitments.filter(
      c => ['pending', 'acknowledged', 'in_progress'].includes(c.status)
    );

    for (const commitment of activeCommitments) {
      const stalenessThreshold = this.calculateStalenessThreshold(commitment, config);
      const daysSinceCommitment = Math.floor(
        (Date.now() - commitment.message.createdAt) / (24 * 60 * 60 * 1000)
      );

      if (daysSinceCommitment >= stalenessThreshold) {
        const staleness = this.calculateStalenessLevel(daysSinceCommitment, stalenessThreshold);
        const relatedEntities = options.includeEntityContext 
          ? await this.getRelatedEntities(commitment)
          : commitment.entities;

        const suggestedActions = await this.generateFollowupSuggestions(
          commitment,
          relatedEntities,
          staleness
        );

        staleActions.push({
          commitment,
          daysSinceStale: daysSinceCommitment - stalenessThreshold,
          stalenessLevel: staleness,
          stalenessReason: this.generateStalenessReason(commitment, daysSinceCommitment, stalenessThreshold),
          suggestedActions,
          relatedEntities
        });
      }
    }

    return staleActions.sort((a, b) => 
      this.getStalenessScore(b.stalenessLevel) - this.getStalenessScore(a.stalenessLevel)
    );
  }

  /**
   * Generate follow-up suggestions based on context
   */
  async suggestFollowups(
    commitment: DetectedCommitment,
    context: {
      relatedEntities?: Entity[];
      conversationHistory?: Message[];
      entityRelationships?: EntityRelationship[];
    } = {}
  ): Promise<FollowupSuggestion[]> {
    const suggestions: FollowupSuggestion[] = [];
    const daysSince = Math.floor((Date.now() - commitment.message.createdAt) / (24 * 60 * 60 * 1000));

    // Status check suggestions
    if (daysSince >= 3 && commitment.status === 'pending') {
      suggestions.push({
        id: this.generateId(),
        suggestionType: 'status_check',
        priority: daysSince > 7 ? 'high' : 'medium',
        suggestionText: `Check status of: "${commitment.commitmentText.substring(0, 50)}..."`,
        confidence: 0.8,
        context: `No updates received for ${daysSince} days`,
        relatedEntities: context.relatedEntities || commitment.entities,
        estimatedUrgency: commitment.urgencyLevel,
        isTimeSensitive: commitment.commitmentType === 'temporal'
      });
    }

    // Deadline reminder suggestions
    if (commitment.commitmentType === 'temporal' && commitment.expectedTimeframeDays) {
      const daysUntilDeadline = commitment.expectedTimeframeDays - daysSince;
      if (daysUntilDeadline <= 1 && daysUntilDeadline >= 0) {
        suggestions.push({
          id: this.generateId(),
          suggestionType: 'deadline_reminder',
          priority: 'urgent',
          suggestionText: `Deadline approaching: "${commitment.commitmentText.substring(0, 50)}..."`,
          confidence: 0.9,
          context: `Deadline in ${daysUntilDeadline} day(s)`,
          relatedEntities: context.relatedEntities || commitment.entities,
          estimatedUrgency: 'urgent',
          isTimeSensitive: true
        });
      }
    }

    // Entity-based suggestions using relationships
    if (context.entityRelationships && context.relatedEntities) {
      const entitySuggestions = await this.generateEntityBasedSuggestions(
        commitment,
        context.entityRelationships,
        context.relatedEntities
      );
      suggestions.push(...entitySuggestions);
    }

    // Context update suggestions for investigation commitments
    if (commitment.commitmentType === 'investigation' && daysSince >= 5) {
      suggestions.push({
        id: this.generateId(),
        suggestionType: 'context_update',
        priority: 'medium',
        suggestionText: `Request update on investigation: "${commitment.commitmentText.substring(0, 50)}..."`,
        confidence: 0.7,
        context: `Investigation ongoing for ${daysSince} days`,
        relatedEntities: context.relatedEntities || commitment.entities,
        estimatedUrgency: commitment.urgencyLevel,
        isTimeSensitive: false
      });
    }

    // Priority-based sorting
    return suggestions.sort((a, b) => {
      const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  /**
   * Analyze a single message for commitments
   */
  private async analyzeMessageForCommitments(
    message: Message,
    options: {
      minConfidence: number;
      includeEntities: boolean;
      conversationContext: boolean;
    }
  ): Promise<DetectedCommitment[]> {
    const commitments: DetectedCommitment[] = [];

    // Check each commitment type
    for (const [type, patterns] of Object.entries(FollowupDetector.COMMITMENT_PATTERNS)) {
      for (const pattern of patterns) {
        const match = message.content.match(pattern);
        if (match) {
          const commitment = await this.createCommitmentFromMatch(
            message,
            type as CommitmentType,
            pattern,
            match,
            options
          );
          if (commitment && commitment.confidence >= options.minConfidence) {
            commitments.push(commitment);
          }
        }
      }
    }

    return commitments;
  }

  /**
   * Create a commitment object from a pattern match
   */
  private async createCommitmentFromMatch(
    message: Message,
    type: CommitmentType,
    pattern: RegExp,
    match: RegExpMatchArray,
    options: {
      includeEntities: boolean;
      conversationContext: boolean;
    }
  ): Promise<DetectedCommitment | null> {
    const sentences = message.content.split(/[.!?]+/);
    const commitmentSentence = sentences.find(s => pattern.test(s))?.trim();
    
    if (!commitmentSentence) return null;

    const confidence = this.calculateCommitmentConfidence(commitmentSentence, pattern, type);
    const urgency = this.determineUrgencyLevel(commitmentSentence);
    const entities = options.includeEntities ? await this.extractEntitiesFromText(commitmentSentence) : [];
    
    let conversationContext = {
      conversationId: message.conversationId,
      participantCount: 1
    };

    if (options.conversationContext) {
      conversationContext = await this.getConversationContext(message.conversationId);
    }

    const daysSince = Math.floor((Date.now() - message.createdAt) / (24 * 60 * 60 * 1000));
    const followUps = await this.findFollowUpMessages(message.conversationId, message.createdAt, commitmentSentence);
    const status = this.determineCommitmentStatus(followUps, daysSince, urgency);

    const commitment: DetectedCommitment = {
      id: this.generateId(),
      message,
      commitmentType: type,
      commitmentText: commitmentSentence,
      matchedPattern: pattern.source,
      confidence,
      entities,
      expectedTimeframeDays: this.extractTimeframe(commitmentSentence),
      urgencyLevel: urgency,
      daysSinceCommitment: daysSince,
      status,
      followUps,
      conversationContext
    };

    return commitment;
  }

  /**
   * Calculate confidence score for a commitment
   */
  private calculateCommitmentConfidence(
    text: string,
    pattern: RegExp,
    type: CommitmentType
  ): number {
    let confidence = 0.6; // Base confidence

    // Type-specific adjustments
    const typeBoosts = {
      action: 0.2,
      temporal: 0.3,
      conditional: 0.1,
      delegated: 0.15,
      investigation: 0.2,
      update: 0.15,
      follow_up: 0.1
    };
    confidence += typeBoosts[type];

    // Pattern specificity boosts
    if (pattern.source.includes("I'll")) confidence += 0.15;
    if (pattern.source.includes("by|before|after")) confidence += 0.2;
    if (text.toLowerCase().includes("urgent") || text.toLowerCase().includes("asap")) confidence += 0.1;
    
    // Text quality indicators
    if (text.length > 20 && text.length < 150) confidence += 0.05;
    if (/\b(?:check|verify|confirm|update|review)\b/i.test(text)) confidence += 0.05;
    
    return Math.min(confidence, 1.0);
  }

  /**
   * Determine urgency level from text
   */
  private determineUrgencyLevel(text: string): UrgencyLevel {
    const lowerText = text.toLowerCase();
    
    if (/\b(?:urgent|asap|immediately|emergency|critical)\b/.test(lowerText)) {
      return 'urgent';
    }
    if (/\b(?:high priority|important|soon|today|tomorrow)\b/.test(lowerText)) {
      return 'high';
    }
    if (/\b(?:when you can|eventually|sometime|later)\b/.test(lowerText)) {
      return 'low';
    }
    
    return 'normal';
  }

  /**
   * Extract entities from commitment text (simplified implementation)
   */
  private async extractEntitiesFromText(_text: string): Promise<Entity[]> {
    // This would typically integrate with an NLP service or entity recognition
    // For now, return empty array - would be implemented with proper entity extraction
    return [];
  }

  /**
   * Get conversation context information
   */
  private async getConversationContext(conversationId: string): Promise<{
    conversationId: string;
    conversationTitle?: string;
    participantCount: number;
  }> {
    const conversation = this.executeStatement<{
      id: string;
      title: string | null;
    }>(
      'get_conversation_context',
      'SELECT id, title FROM conversations WHERE id = ?',
      [conversationId]
    );

    // Count unique participants (roles)
    const { count } = this.executeStatement<{ count: number }>(
      'count_participants',
      'SELECT COUNT(DISTINCT role) as count FROM messages WHERE conversation_id = ?',
      [conversationId]
    );

    return {
      conversationId,
      conversationTitle: conversation?.title || undefined,
      participantCount: count || 1
    };
  }

  /**
   * Find follow-up messages related to a commitment
   */
  private async findFollowUpMessages(
    conversationId: string,
    afterTimestamp: number,
    commitmentText: string
  ): Promise<Message[]> {
    const keywords = this.extractKeywords(commitmentText);
    if (keywords.length === 0) return [];

    const rows = this.executeStatementAll<{
      id: string;
      conversation_id: string;
      role: string;
      content: string;
      created_at: number;
      parent_message_id: string | null;
      metadata: string;
    }>(
      'find_followup_messages',
      `SELECT m.*
       FROM messages_fts
       JOIN messages m ON m.rowid = messages_fts.rowid
       WHERE m.conversation_id = ? 
         AND m.created_at > ?
         AND messages_fts MATCH ?
       ORDER BY m.created_at ASC`,
      [conversationId, afterTimestamp, keywords.join(' OR ')]
    );

    return rows.map(row => this.mapRowToMessage(row));
  }

  /**
   * Determine commitment status based on follow-ups
   */
  private determineCommitmentStatus(
    followUps: Message[],
    daysSince: number,
    urgency: UrgencyLevel
  ): CommitmentStatus {
    if (followUps.length === 0) {
      const urgencyThresholds = { urgent: 1, high: 3, normal: 7, low: 14 };
      return daysSince > urgencyThresholds[urgency] ? 'overdue' : 'pending';
    }

    // Check for completion indicators
    const hasCompletion = followUps.some(msg => 
      FollowupDetector.COMPLETION_PATTERNS.some(pattern => pattern.test(msg.content))
    );
    if (hasCompletion) return 'completed';

    // Check for acknowledgment or progress
    const hasAcknowledgment = followUps.some(msg =>
      FollowupDetector.ACKNOWLEDGMENT_PATTERNS.some(pattern => pattern.test(msg.content))
    );
    if (hasAcknowledgment) return 'in_progress';

    return 'acknowledged';
  }

  /**
   * Extract timeframe from commitment text
   */
  private extractTimeframe(text: string): number | undefined {
    const lowerText = text.toLowerCase();
    
    if (lowerText.includes('today') || lowerText.includes('immediately')) return 0;
    if (lowerText.includes('tomorrow')) return 1;
    if (lowerText.includes('this week') || lowerText.includes('by friday')) return 7;
    if (lowerText.includes('next week')) return 14;
    if (lowerText.includes('this month') || lowerText.includes('end of month')) return 30;
    
    // Extract numeric timeframes
    const match = lowerText.match(/(?:in|within)\s+(\d+)\s+(hour|day|week|month)s?/);
    if (match) {
      const value = parseInt(match[1]);
      const unit = match[2];
      const multipliers = { hour: 1/24, day: 1, week: 7, month: 30 };
      return Math.ceil(value * multipliers[unit as keyof typeof multipliers]);
    }
    
    return undefined;
  }

  /**
   * Extract temporal information from commitment text
   */
  private extractTemporalInfo(text: string): {
    deadline?: number;
    timeReference: 'absolute' | 'relative' | 'recurring';
    timeExpression: string;
  } | null {
    // This is a simplified implementation
    // In practice, this would use more sophisticated NLP for date/time parsing
    const timeframe = this.extractTimeframe(text);
    if (!timeframe) return null;

    const deadline = Date.now() + (timeframe * 24 * 60 * 60 * 1000);
    
    return {
      deadline,
      timeReference: 'relative', // Could be enhanced to detect absolute dates
      timeExpression: text.match(/(?:by|before|after|on|in|within).+?(?:\.|$|,)/i)?.[0] || ''
    };
  }

  /**
   * Get all commitments for analysis
   */
  private async getAllCommitments(conversationId?: string): Promise<DetectedCommitment[]> {
    let whereClause = 'WHERE m.role = ?';
    const params: any[] = ['assistant'];

    if (conversationId) {
      whereClause += ' AND m.conversation_id = ?';
      params.push(conversationId);
    }

    const messages = this.executeStatementAll<{
      id: string;
      conversation_id: string;
      role: string;
      content: string;
      created_at: number;
      parent_message_id: string | null;
      metadata: string;
    }>(
      'get_all_messages_for_commitments',
      `SELECT m.* FROM messages m ${whereClause} ORDER BY m.created_at DESC`,
      params
    );

    const commitments: DetectedCommitment[] = [];
    for (const row of messages) {
      const message = this.mapRowToMessage(row);
      const messageCommitments = await this.analyzeMessageForCommitments(message, {
        minConfidence: 0.5,
        includeEntities: true,
        conversationContext: false
      });
      commitments.push(...messageCommitments);
    }

    return commitments;
  }

  /**
   * Calculate staleness threshold for a commitment
   */
  private calculateStalenessThreshold(
    commitment: DetectedCommitment,
    config: StalenessConfig
  ): number {
    // Start with urgency-based threshold
    let threshold = config.urgencyThresholds[commitment.urgencyLevel];

    // Apply commitment type rules
    const typeRule = config.commitmentTypeRules[commitment.commitmentType];
    if (typeRule !== undefined) {
      threshold = Math.min(threshold, typeRule);
    }

    // Apply entity-based rules
    for (const entity of commitment.entities) {
      const entityRule = config.entityBasedRules[entity.type];
      if (entityRule !== undefined) {
        threshold = Math.min(threshold, entityRule);
      }
    }

    return Math.max(threshold, 1); // Minimum 1 day
  }

  /**
   * Calculate staleness level
   */
  private calculateStalenessLevel(
    daysSinceCommitment: number,
    threshold: number
  ): StaleAction['stalenessLevel'] {
    const ratio = daysSinceCommitment / threshold;
    
    if (ratio >= 3) return 'abandoned';
    if (ratio >= 2) return 'very_stale';
    if (ratio >= 1.5) return 'stale';
    return 'mildly_stale';
  }

  /**
   * Generate staleness reason
   */
  private generateStalenessReason(
    commitment: DetectedCommitment,
    daysSinceCommitment: number,
    threshold: number
  ): string {
    return `Commitment made ${daysSinceCommitment} days ago (threshold: ${threshold} days). ` +
           `Type: ${commitment.commitmentType}, Urgency: ${commitment.urgencyLevel}`;
  }

  /**
   * Get staleness score for sorting
   */
  private getStalenessScore(level: StaleAction['stalenessLevel']): number {
    const scores = {
      'abandoned': 4,
      'very_stale': 3,
      'stale': 2,
      'mildly_stale': 1
    };
    return scores[level];
  }

  /**
   * Get related entities using relationships
   */
  private async getRelatedEntities(commitment: DetectedCommitment): Promise<Entity[]> {
    // This would query entity relationships to find connected entities
    // Implementation would depend on entity relationship system
    return commitment.entities;
  }

  /**
   * Generate follow-up suggestions based on commitment
   */
  private async generateFollowupSuggestions(
    commitment: DetectedCommitment,
    relatedEntities: Entity[],
    _staleness: StaleAction['stalenessLevel']
  ): Promise<FollowupSuggestion[]> {
    // Use the main suggestFollowups method
    return this.suggestFollowups(commitment, { relatedEntities });
  }

  /**
   * Generate entity-based suggestions using relationships
   */
  private async generateEntityBasedSuggestions(
    commitment: DetectedCommitment,
    relationships: EntityRelationship[],
    entities: Entity[]
  ): Promise<FollowupSuggestion[]> {
    const suggestions: FollowupSuggestion[] = [];

    // Find relevant relationships for escalation suggestions
    for (const entity of entities) {
      const entityRelationships = relationships.filter(
        r => r.sourceEntityId === entity.id || r.targetEntityId === entity.id
      );

      for (const rel of entityRelationships) {
        if (rel.relationshipType === 'works_for' || rel.relationshipType === 'part_of') {
          suggestions.push({
            id: this.generateId(),
            suggestionType: 'escalation',
            priority: 'medium',
            suggestionText: `Consider escalating to related ${rel.relationshipType} entity`,
            confidence: 0.6,
            context: `Entity relationship: ${rel.relationshipType}`,
            relatedEntities: [entity],
            estimatedUrgency: commitment.urgencyLevel,
            isTimeSensitive: commitment.commitmentType === 'temporal'
          });
        }
      }
    }

    return suggestions;
  }

  /**
   * Extract keywords from text for searching
   */
  private extractKeywords(text: string): string[] {
    const words = text.toLowerCase().split(/\s+/);
    const stopWords = new Set(['i', 'will', 'ill', 'let', 'me', 'need', 'to', 'the', 'a', 'an', 'and', 'or', 'but']);
    
    return words
      .filter(word => word.length > 3 && !stopWords.has(word))
      .slice(0, 5);
  }

  /**
   * Map database row to Message object
   */
  private mapRowToMessage(row: any): Message {
    return {
      id: row.id,
      conversationId: row.conversation_id,
      role: row.role as 'user' | 'assistant' | 'system',
      content: row.content,
      createdAt: row.created_at,
      parentMessageId: row.parent_message_id || undefined,
      metadata: this.parseMetadata(row.metadata)
    };
  }
}