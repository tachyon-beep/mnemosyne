/**
 * Follow-up Detection System - Advanced commitment language detection and follow-up tracking
 *
 * This service provides comprehensive tracking of commitments, promises, and action items
 * with intelligent follow-up suggestions and stale action detection.
 *
 * Features:
 * - Multi-pattern commitment detection (action, temporal, conditional, delegated)
 * - Entity-aware follow-up tracking with relationship context
 * - Configurable staleness detection with urgency awareness
 * - Smart follow-up suggestions based on conversation patterns
 * - Completion indicator detection and resolution tracking
 */
import { BaseRepository } from '../../../storage/repositories/BaseRepository.js';
import { Message } from '../../../types/interfaces.js';
import { Entity, EntityType } from '../../../storage/repositories/EntityRepository.js';
import { EntityRelationship } from '../../../entities/RelationshipDetector.js';
/**
 * Represents a detected commitment in conversation
 */
export interface DetectedCommitment {
    /** Unique identifier for this commitment */
    id: string;
    /** The message containing the commitment */
    message: Message;
    /** Type of commitment detected */
    commitmentType: CommitmentType;
    /** Extracted commitment text */
    commitmentText: string;
    /** Pattern that matched the commitment */
    matchedPattern: string;
    /** Confidence score (0-1) */
    confidence: number;
    /** Entities mentioned in the commitment */
    entities: Entity[];
    /** Expected resolution timeframe in days */
    expectedTimeframeDays?: number;
    /** Urgency level based on language and context */
    urgencyLevel: UrgencyLevel;
    /** Days since commitment was made */
    daysSinceCommitment: number;
    /** Status of the commitment */
    status: CommitmentStatus;
    /** Related follow-up messages */
    followUps: Message[];
    /** Conversation context */
    conversationContext: {
        conversationId: string;
        conversationTitle?: string;
        participantCount: number;
    };
}
/**
 * Types of commitments that can be detected
 */
export type CommitmentType = 'action' | 'temporal' | 'conditional' | 'delegated' | 'investigation' | 'update' | 'follow_up';
/**
 * Urgency levels for commitments
 */
export type UrgencyLevel = 'low' | 'normal' | 'high' | 'urgent';
/**
 * Status of commitment tracking
 */
export type CommitmentStatus = 'pending' | 'acknowledged' | 'in_progress' | 'completed' | 'overdue' | 'cancelled';
/**
 * Temporal commitment with specific time reference
 */
export interface TemporalCommitment extends DetectedCommitment {
    commitmentType: 'temporal';
    /** Specific deadline extracted from text */
    deadline?: number;
    /** Time reference type */
    timeReference: 'absolute' | 'relative' | 'recurring';
    /** Original time expression */
    timeExpression: string;
}
/**
 * Stale action that needs follow-up
 */
export interface StaleAction {
    /** The original commitment */
    commitment: DetectedCommitment;
    /** Days since it became stale */
    daysSinceStale: number;
    /** Staleness level */
    stalenessLevel: 'mildly_stale' | 'stale' | 'very_stale' | 'abandoned';
    /** Reason why it's considered stale */
    stalenessReason: string;
    /** Suggested follow-up actions */
    suggestedActions: FollowupSuggestion[];
    /** Related entities for context */
    relatedEntities: Entity[];
}
/**
 * Follow-up suggestion generated by the system
 */
export interface FollowupSuggestion {
    /** Unique identifier for the suggestion */
    id: string;
    /** Type of follow-up suggested */
    suggestionType: FollowupType;
    /** Priority level */
    priority: 'low' | 'medium' | 'high' | 'urgent';
    /** Suggested action text */
    suggestionText: string;
    /** Confidence in the suggestion (0-1) */
    confidence: number;
    /** Context for the suggestion */
    context: string;
    /** Related entities */
    relatedEntities: Entity[];
    /** Estimated urgency based on patterns */
    estimatedUrgency: UrgencyLevel;
    /** Whether this suggestion is time-sensitive */
    isTimeSensitive: boolean;
}
/**
 * Types of follow-up suggestions
 */
export type FollowupType = 'status_check' | 'deadline_reminder' | 'context_update' | 'escalation' | 'clarification' | 'completion_verify' | 'timeline_adjust';
/**
 * Configuration for staleness detection
 */
export interface StalenessConfig {
    /** Default staleness threshold in days */
    defaultStaleDays: number;
    /** Urgency-based thresholds */
    urgencyThresholds: {
        low: number;
        normal: number;
        high: number;
        urgent: number;
    };
    /** Entity-specific staleness rules */
    entityBasedRules: {
        [entityType in EntityType]?: number;
    };
    /** Commitment type specific rules */
    commitmentTypeRules: {
        [type in CommitmentType]?: number;
    };
}
/**
 * Follow-up Detection Service
 */
export declare class FollowupDetector extends BaseRepository {
    /**
     * Comprehensive commitment detection patterns
     */
    private static readonly COMMITMENT_PATTERNS;
    /**
     * Patterns for detecting completion indicators
     */
    private static readonly COMPLETION_PATTERNS;
    /**
     * Patterns for detecting acknowledgment
     */
    private static readonly ACKNOWLEDGMENT_PATTERNS;
    /**
     * Default staleness configuration
     */
    private static readonly DEFAULT_STALENESS_CONFIG;
    /**
     * Detect commitment language in messages
     */
    detectCommitmentLanguage(messages: Message[], options?: {
        minConfidence?: number;
        includeEntities?: boolean;
        conversationContext?: boolean;
    }): Promise<DetectedCommitment[]>;
    /**
     * Track temporal promises with specific time references
     */
    trackTemporalPromises(conversationId?: string, options?: {
        includePast?: boolean;
        includeCompleted?: boolean;
        maxDaysAhead?: number;
    }): Promise<TemporalCommitment[]>;
    /**
     * Identify stale actions that need follow-up
     */
    identifyStaleActions(options?: {
        conversationId?: string;
        stalenessConfig?: Partial<StalenessConfig>;
        includeEntityContext?: boolean;
    }): Promise<StaleAction[]>;
    /**
     * Generate follow-up suggestions based on context
     */
    suggestFollowups(commitment: DetectedCommitment, context?: {
        relatedEntities?: Entity[];
        conversationHistory?: Message[];
        entityRelationships?: EntityRelationship[];
    }): Promise<FollowupSuggestion[]>;
    /**
     * Analyze a single message for commitments
     */
    private analyzeMessageForCommitments;
    /**
     * Create a commitment object from a pattern match
     */
    private createCommitmentFromMatch;
    /**
     * Calculate confidence score for a commitment
     */
    private calculateCommitmentConfidence;
    /**
     * Determine urgency level from text
     */
    private determineUrgencyLevel;
    /**
     * Extract entities from commitment text (simplified implementation)
     */
    private extractEntitiesFromText;
    /**
     * Get conversation context information
     */
    private getConversationContext;
    /**
     * Find follow-up messages related to a commitment
     */
    private findFollowUpMessages;
    /**
     * Determine commitment status based on follow-ups
     */
    private determineCommitmentStatus;
    /**
     * Extract timeframe from commitment text
     */
    private extractTimeframe;
    /**
     * Extract temporal information from commitment text
     */
    private extractTemporalInfo;
    /**
     * Get all commitments for analysis
     */
    private getAllCommitments;
    /**
     * Calculate staleness threshold for a commitment
     */
    private calculateStalenessThreshold;
    /**
     * Calculate staleness level
     */
    private calculateStalenessLevel;
    /**
     * Generate staleness reason
     */
    private generateStalenessReason;
    /**
     * Get staleness score for sorting
     */
    private getStalenessScore;
    /**
     * Get related entities using relationships
     */
    private getRelatedEntities;
    /**
     * Generate follow-up suggestions based on commitment
     */
    private generateFollowupSuggestions;
    /**
     * Generate entity-based suggestions using relationships
     */
    private generateEntityBasedSuggestions;
    /**
     * Extract keywords from text for searching
     */
    private extractKeywords;
    /**
     * Map database row to Message object
     */
    private mapRowToMessage;
}
//# sourceMappingURL=FollowupDetector.d.ts.map