/**
 * Provider Manager
 *
 * Manages multiple LLM providers with fallback chains, health monitoring,
 * and intelligent provider selection for conversation summarization.
 */
import { ProviderError, ProviderUnavailableError, ProviderQuotaError } from './providers/LLMProvider.js';
import { OllamaProvider } from './providers/OllamaProvider.js';
import { OpenAIProvider } from './providers/OpenAIProvider.js';
/**
 * Provider Manager class
 */
export class ProviderManager {
    providers = new Map();
    providerStatus = new Map();
    config;
    healthCheckTimer;
    dailyUsage;
    constructor(config) {
        this.config = config;
        this.dailyUsage = this.initializeDailyUsage();
        this.startHealthChecking();
    }
    /**
     * Register a provider
     */
    async registerProvider(config) {
        try {
            const provider = await this.createProvider(config);
            await provider.initialize();
            this.providers.set(config.id, provider);
            this.providerStatus.set(config.id, {
                provider,
                isHealthy: true,
                lastChecked: new Date(),
                consecutiveFailures: 0,
                avgLatency: 0,
                totalCost: 0
            });
            console.log(`Provider registered: ${config.name} (${config.id})`);
        }
        catch (error) {
            console.error(`Failed to register provider ${config.name}:`, error);
            throw error;
        }
    }
    /**
     * Unregister a provider
     */
    async unregisterProvider(providerId) {
        const provider = this.providers.get(providerId);
        if (provider) {
            await provider.cleanup();
            this.providers.delete(providerId);
            this.providerStatus.delete(providerId);
            console.log(`Provider unregistered: ${providerId}`);
        }
    }
    /**
     * Generate summary using best available provider
     */
    async generateSummary(summaryRequest, strategy = this.config.defaultStrategy) {
        const selection = await this.selectProvider(strategy, summaryRequest);
        let lastError;
        // Try primary provider and fallback chain
        for (const providerId of [selection.provider.getId(), ...selection.fallbackChain]) {
            const provider = this.providers.get(providerId);
            if (!provider)
                continue;
            const status = this.providerStatus.get(providerId);
            if (!status?.isHealthy)
                continue;
            // Check cost limits
            if (await this.wouldExceedCostLimit(provider, summaryRequest)) {
                console.log(`Skipping provider ${providerId} due to cost limit`);
                continue;
            }
            try {
                const startTime = Date.now();
                const response = await this.executeWithRetry(provider, summaryRequest);
                const latency = Date.now() - startTime;
                // Update status
                this.updateProviderStatus(providerId, true, latency, response.cost || 0);
                this.updateDailyUsage(providerId, response.cost || 0);
                console.log(`Summary generated by ${provider.getName()} in ${latency}ms`);
                return response;
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error('Unknown error');
                console.warn(`Provider ${providerId} failed:`, lastError.message);
                this.updateProviderStatus(providerId, false, 0, 0);
                // Skip to next provider unless it's a quota error (permanent)
                if (error instanceof ProviderQuotaError) {
                    this.markProviderUnhealthy(providerId, 'Quota exceeded');
                }
            }
        }
        // All providers failed
        throw new ProviderError(`All providers failed. Last error: ${lastError?.message || 'Unknown error'}`, 'ALL_PROVIDERS_FAILED', 'ProviderManager', lastError);
    }
    /**
     * Get provider statistics
     */
    getProviderStats() {
        return Array.from(this.providers.values()).map(provider => {
            const status = this.providerStatus.get(provider.getId());
            const dailyUsage = this.dailyUsage.providerUsage[provider.getId()];
            const stats = provider.getStats();
            return {
                id: provider.getId(),
                name: provider.getName(),
                type: provider.getType(),
                isHealthy: status?.isHealthy || false,
                consecutiveFailures: status?.consecutiveFailures || 0,
                avgLatency: status?.avgLatency || 0,
                totalCost: stats.totalCost,
                dailyCost: dailyUsage?.cost || 0,
                dailyRequests: dailyUsage?.requests || 0
            };
        });
    }
    /**
     * Get daily usage summary
     */
    getDailyUsage() {
        return { ...this.dailyUsage };
    }
    /**
     * Get healthy providers
     */
    getHealthyProviders() {
        return Array.from(this.providers.values()).filter(provider => {
            const status = this.providerStatus.get(provider.getId());
            return status?.isHealthy;
        });
    }
    /**
     * Manual health check for all providers
     */
    async checkAllProviders() {
        console.log('Performing health check on all providers...');
        const promises = Array.from(this.providers.entries()).map(async ([id, provider]) => {
            try {
                const health = await provider.getHealth();
                const status = this.providerStatus.get(id);
                if (status) {
                    status.isHealthy = health.isAvailable;
                    status.lastChecked = new Date();
                    status.avgLatency = health.latency || status.avgLatency;
                    if (health.isAvailable) {
                        status.consecutiveFailures = 0;
                    }
                }
                console.log(`Provider ${provider.getName()}: ${health.isAvailable ? 'healthy' : 'unhealthy'}`);
            }
            catch (error) {
                console.error(`Health check failed for ${provider.getName()}:`, error);
                this.markProviderUnhealthy(id, error instanceof Error ? error.message : 'Health check failed');
            }
        });
        await Promise.all(promises);
    }
    /**
     * Cleanup resources
     */
    async cleanup() {
        if (this.healthCheckTimer) {
            clearInterval(this.healthCheckTimer);
        }
        const cleanupPromises = Array.from(this.providers.values()).map(provider => provider.cleanup().catch(error => console.error(`Cleanup failed for ${provider.getName()}:`, error)));
        await Promise.all(cleanupPromises);
        this.providers.clear();
        this.providerStatus.clear();
    }
    /**
     * Create provider instance based on configuration
     */
    async createProvider(config) {
        switch (config.type) {
            case 'local':
                if (config.endpoint?.includes('ollama') || config.name.toLowerCase().includes('ollama')) {
                    return new OllamaProvider(config);
                }
                throw new Error(`Unsupported local provider: ${config.name}`);
            case 'external':
                if (config.endpoint?.includes('openai') || config.name.toLowerCase().includes('openai')) {
                    return new OpenAIProvider(config);
                }
                throw new Error(`Unsupported external provider: ${config.name}`);
            default:
                throw new Error(`Unknown provider type: ${config.type}`);
        }
    }
    /**
     * Select best provider based on strategy
     */
    async selectProvider(strategy, _request) {
        const healthyProviders = this.getHealthyProviders();
        if (healthyProviders.length === 0) {
            throw new ProviderUnavailableError('ProviderManager');
        }
        let selectedProvider;
        let reason;
        switch (strategy) {
            case 'priority':
                selectedProvider = healthyProviders.sort((a, b) => b.getPriority() - a.getPriority())[0];
                reason = 'Highest priority';
                break;
            case 'cost-optimal':
                selectedProvider = healthyProviders.sort((a, b) => {
                    const costA = a.estimateCost(1000); // Compare cost per 1k tokens
                    const costB = b.estimateCost(1000);
                    return costA - costB;
                })[0];
                reason = 'Lowest cost';
                break;
            case 'performance':
                selectedProvider = healthyProviders.sort((a, b) => {
                    const statusA = this.providerStatus.get(a.getId());
                    const statusB = this.providerStatus.get(b.getId());
                    return (statusA?.avgLatency || Infinity) - (statusB?.avgLatency || Infinity);
                })[0];
                reason = 'Fastest response';
                break;
            case 'quality':
                // Prefer external providers for quality, local for privacy
                const externalProviders = healthyProviders.filter(p => p.getType() === 'external');
                selectedProvider = externalProviders.length > 0 ? externalProviders[0] : healthyProviders[0];
                reason = externalProviders.length > 0 ? 'Highest quality (external)' : 'Best available';
                break;
            case 'fallback':
            default:
                selectedProvider = healthyProviders.sort((a, b) => b.getPriority() - a.getPriority())[0];
                reason = 'Fallback strategy';
                break;
        }
        // Create fallback chain (excluding selected provider)
        const fallbackChain = healthyProviders
            .filter(p => p.getId() !== selectedProvider.getId())
            .sort((a, b) => b.getPriority() - a.getPriority())
            .map(p => p.getId());
        return {
            provider: selectedProvider,
            reason,
            fallbackChain
        };
    }
    /**
     * Execute request with retry logic
     */
    async executeWithRetry(provider, request) {
        let lastError;
        for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
            try {
                return await provider.generateSummary(request);
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error('Unknown error');
                // Don't retry on certain errors
                if (error instanceof ProviderQuotaError ||
                    error instanceof ProviderUnavailableError) {
                    throw error;
                }
                // Wait before retry (exponential backoff)
                if (attempt < this.config.maxRetries) {
                    const delay = this.config.retryDelay * Math.pow(2, attempt - 1);
                    console.log(`Retry ${attempt} for ${provider.getName()} in ${delay}ms`);
                    await this.sleep(delay);
                }
            }
        }
        throw lastError || new Error('Max retries exceeded');
    }
    /**
     * Check if request would exceed cost limit
     */
    async wouldExceedCostLimit(provider, request) {
        if (!this.config.costLimit || provider.getType() === 'local') {
            return false; // No limit or local provider (free)
        }
        // Estimate cost for this request
        const inputTokens = await provider.countTokens(request.messages.map(m => m.content).join(' '));
        const estimatedCost = provider.estimateCost(inputTokens.count + 200); // +200 for output
        return (this.dailyUsage.totalCost + estimatedCost) > this.config.costLimit;
    }
    /**
     * Update provider status
     */
    updateProviderStatus(providerId, success, latency, cost) {
        const status = this.providerStatus.get(providerId);
        if (!status)
            return;
        if (success) {
            status.isHealthy = true;
            status.consecutiveFailures = 0;
            status.avgLatency = (status.avgLatency + latency) / 2; // Simple average
            status.totalCost += cost;
        }
        else {
            status.consecutiveFailures++;
            if (status.consecutiveFailures >= 3) {
                status.isHealthy = false;
            }
        }
        status.lastChecked = new Date();
    }
    /**
     * Mark provider as unhealthy
     */
    markProviderUnhealthy(providerId, reason) {
        const status = this.providerStatus.get(providerId);
        if (status) {
            status.isHealthy = false;
            status.consecutiveFailures = 99; // High number to indicate permanent failure
            console.warn(`Provider ${providerId} marked unhealthy: ${reason}`);
        }
    }
    /**
     * Update daily usage tracking
     */
    updateDailyUsage(providerId, cost) {
        const today = new Date().toISOString().split('T')[0];
        if (this.dailyUsage.date !== today) {
            this.dailyUsage = this.initializeDailyUsage();
        }
        this.dailyUsage.totalCost += cost;
        this.dailyUsage.requestCount++;
        if (!this.dailyUsage.providerUsage[providerId]) {
            this.dailyUsage.providerUsage[providerId] = { cost: 0, requests: 0 };
        }
        this.dailyUsage.providerUsage[providerId].cost += cost;
        this.dailyUsage.providerUsage[providerId].requests++;
    }
    /**
     * Initialize daily usage tracking
     */
    initializeDailyUsage() {
        return {
            date: new Date().toISOString().split('T')[0],
            totalCost: 0,
            requestCount: 0,
            providerUsage: {}
        };
    }
    /**
     * Start health checking timer
     */
    startHealthChecking() {
        this.healthCheckTimer = setInterval(() => this.checkAllProviders().catch(console.error), this.config.healthCheckInterval);
    }
    /**
     * Sleep utility
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
//# sourceMappingURL=ProviderManager.js.map